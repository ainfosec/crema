![Crema-rado.png](https://bitbucket.org/repo/arMj8M/images/192944102-Crema-rado.png)
# Crema
(C) 2014 Assured Information Security, Inc.

## Introduction
Crema is a LLVM front-end that aims to specifically execute in sub-Turing Complete space.
Designed to be simple to learn, and practical for the majority of programming tasks needed,
Crema can restrict the computational complexity of the program to the minimum needed to improve
security.

## Technical Details
Crema is developed in C++ in order to natively utilize the LLVM tool-chain and integrate with
flex/bison to simplify parser generation.

## Getting started
Start off by cloning the latest version of Crema from this git repository

### Building the Crema Tool
Before building the Crema tool, make sure that you have the following dependencies installed on your environment:

1. g++
2. bison: 		http://www.gnu.org/software/bison/
3. llvm-dev
4. flex:		http://flex.sourceforge.net/

Build the Crema tool by running ```make``` in the src directory. This will create the "cremacc" program. You can clean the src directory by running ```make clean```

### Compiling your Crema programs with cremacc
To compile a Crema program into LLVM IR for JIT execution, simply use the "cremacc" program.

Crema files use the extention ".crema". To build a creama file into an executable named "program.exe", use the command:
```
./cremacc -f <path-to-a-crema-file> -o program
```

To print LLVM assembly to a file, use the -S option:
``` ./cremacc -f <path-to-a-crema-file> -S <output-file-name>.ll```

For help with all of the other command line options available for cremacc, simply run:
```./cremacc -h```

## Crema Syntax
Crema is designed in the popular procedural paradigm, following a number of C styles while adopting 
some newer features from more modern languages like Python and Ruby. Crema code is written without the use of semicolons or end-of-line characters. Whitespace is completely ignored by the compiler. 

### Comments
You can make comments in a crema program using the ```#``` symbol:
```
# This comment will be ignored by the compiler
```

### Variables and Data types
Crema uses the following data types for variables and/or return values

| Type 	  | Description											|
|---------|-----------------------------------------------------|
| int 	  | A 32-bit signed integer value						|
| double  | A 64-bit signed floating-point decimal value		|
| char    | A single character (UTF-8??)						|
| string  | A string of characters (UTF-8??)					|
| bool 	  | A boolean value, "true" or "false"					|
| struct  | A C-like structure									|
| void 	  | (reserved for return types?)						|
| invalid | (reserved for internal use?)						|

Variables can be declared anywhere in a Crema file like this:
```
int x
```
Or defined with a value like this:
```
bool b = true
```

Crema is a statically typed language, meaning that you are not permitted to change the data type of a variable at run time:
```
int number = 10

number = 12
number = "String"	# <-- Error
```

### Numbers
There are two data types in crema that represnt numbers: ```int``` and ```double```
```
int x = 2
double d = 5.0
```
Crema automatically casts values from an int to a double for you:
```
double d = 2 	# <-- d == 2.0
```

### Strings and Characters
Crema strings can be definied using double-quotes around a string literal:
```
string str = "Hello, World"
```
You can print strings using the standard lib ```str_print()``` and ```str_println()``` functions:
```
string str1 = "Hello, "
string str2 = "World"
str_print(str1)
str_println(str2)

# Outputs: "Hello, World" (str_print() doesn't trigger a new line)
```
Characters can be defined with single quotes
```
char c = 'a'
```

Currently, Crema does not support escape characters or formatted printing. For example, the following will print the given string literal exactly as it is written:
```
str_println("escape \n characters \t\t not supported")	# <-- This will print literally
```
### Boolean Values
Crema uses the lower-case keywords ```true``` and ```false``` to define boolean values
```
boolean b1 = true
boolean b2 = false
```

### Structures
Structures can be defined to build more complex data types:
```
# Declare a new person stucture
struct person{
	string name,
	int age
}

# Create a person stucture
struct person p1
p1.name = John
p1.age = 26

p1.age = p1.age + 10
```

### Arrays
Crema arrays can be defined for the following data types...
```
int array1[] = [1, 2, 3, 4, 5]
char array2[] = ['a', 'l', 'l']
double array3[] = [1.0, 1.2, 1.3]
string array4[] = ["bob", "alice"]
bool array5[] = [true, false]

# ...

```

... and you can access elements of an array like this:
```
# ...

int x = array1[0]	# <-- x == 1
array2[2] = 'e'		# <-- array2 == ['a', 'l', 'e']
```

### Operators
Crema supports the following mathematical operators for numerical data types:
```
int x = 2
int y = 3
int result

result = x + y 		# result == 5
result = x - y  	# result == -1
result = x * y 		# result == 6
result = y / x 		# result == 1
result = y % x 		# result == 1
result = x | y 		# result == 3
result = x & y  	# result == 2
result = x ^ y 		# result == 1
```

Crema supports the following logical operators:
```
bool b1 = true
bool b2 = false
int x = 2
int y = 3
bool result

result = b1 && b2	# result == false
result = b1 || b2	# result == true
result = x == y 	# result == false
result = x != y 	# result == true
result = x > y 		# result == false
result = x < y 		# result == true
result = x >= y 	# result == false
result = x <= y 	# result == true
```

The following common operators are currently NOT supported by Crema:
```
x++
x--
~x
x >> 1
x << 1
(x == 5) ? 1 : 10
```

### Conditional Statements
Crema supports standard if, else if, and else statements for conditional processing
```
int a = 1

if(a > 0){
	str_println("a > 0")
}else if(a == 0){
	str_println("a == 0")
}else{
	str_println("a < 0")
}
```
The common `switch` expression is currently NOT supported

### Loops
The only type of loop supported by Crema is the ```foreach``` loop. This is because... (Jacob, insert some technical mumbo-jumbo here...)
```
char letters[] = ['C', 'r', 'e', 'm', 'a', ' ', 'R', 'o', 'c', 'k', 's', '!']

# print the letters (Crema Rocks!)
foreach(letters as i){
	str_print(i)
}
```

### Functions
Functions in Crema can be defined using the syntax: def <returnType> <functionName>(){}

All functions must have either a return type, or specify ```void``` if no value is returned.
For example:
```
def int foo(){
	return 0;
}

def void bar(){
	
}
```
You can pass parameters to functions like this:
```
def int add(int a, int b){
	return a + b
}

def void printString(string str){
	str_println(str)
}

# ...
```
... And call a function like this:
```
# ...

int x = add(3, 2)

printString("Hello, World")
```

## Variable Scope
Variables in Crema follow C-like lexical scope rules. 
Variables can be definied globally (accessable by all crema funcitons) or locally within a function. Variables definied locally within a function take precedence over global variables that have the same name.

```
int x = 5		# <-- Global Variable
int y

def int foo(){
	int x = 10	# <-- Local Variable
	return x	# <-- Local variable x equals 10, x in global scope is unchanged
}

def int bar(){
	return x	# <-- Inherits x from global scope
}

y = foo()		# <-- y == 10
y = bar()		# <-- y == 5
```

Functions in Crema may only be defined in global scope. Nested functions definitions are not permitted:
```
def void foo(){			# <-- Good
	str_println("This is how to define a function in Crema")
}

def void bar(){
	def void foo2(){	# <-- Bad. This is not valid in Crema
		str_println("This nested function will cause a compliler error")
	}
}
```